// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ssl_simulation_config.proto

#include "ssl_simulation_config.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr RobotLimits::RobotLimits(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : acc_speedup_absolute_max_(0)
  , acc_speedup_angular_max_(0)
  , acc_brake_absolute_max_(0)
  , acc_brake_angular_max_(0)
  , vel_absolute_max_(0)
  , vel_angular_max_(0){}
struct RobotLimitsDefaultTypeInternal {
  constexpr RobotLimitsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RobotLimitsDefaultTypeInternal() {}
  union {
    RobotLimits _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RobotLimitsDefaultTypeInternal _RobotLimits_default_instance_;
constexpr RobotWheelAngles::RobotWheelAngles(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : front_right_(0)
  , back_right_(0)
  , back_left_(0)
  , front_left_(0){}
struct RobotWheelAnglesDefaultTypeInternal {
  constexpr RobotWheelAnglesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RobotWheelAnglesDefaultTypeInternal() {}
  union {
    RobotWheelAngles _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RobotWheelAnglesDefaultTypeInternal _RobotWheelAngles_default_instance_;
constexpr RobotSpecs::RobotSpecs(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : custom_()
  , id_(nullptr)
  , limits_(nullptr)
  , wheel_angles_(nullptr)
  , mass_(0)
  , max_linear_kick_speed_(0)
  , max_chip_kick_speed_(0)
  , center_to_dribbler_(0)
  , radius_(0.09f)
  , height_(0.15f){}
struct RobotSpecsDefaultTypeInternal {
  constexpr RobotSpecsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RobotSpecsDefaultTypeInternal() {}
  union {
    RobotSpecs _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RobotSpecsDefaultTypeInternal _RobotSpecs_default_instance_;
constexpr RealismConfig::RealismConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : custom_(){}
struct RealismConfigDefaultTypeInternal {
  constexpr RealismConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RealismConfigDefaultTypeInternal() {}
  union {
    RealismConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RealismConfigDefaultTypeInternal _RealismConfig_default_instance_;
constexpr SimulatorConfig::SimulatorConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : robot_specs_()
  , geometry_(nullptr)
  , realism_config_(nullptr)
  , vision_port_(0u){}
struct SimulatorConfigDefaultTypeInternal {
  constexpr SimulatorConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SimulatorConfigDefaultTypeInternal() {}
  union {
    SimulatorConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SimulatorConfigDefaultTypeInternal _SimulatorConfig_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_ssl_5fsimulation_5fconfig_2eproto[5];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_ssl_5fsimulation_5fconfig_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_ssl_5fsimulation_5fconfig_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_ssl_5fsimulation_5fconfig_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::RobotLimits, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::RobotLimits, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::RobotLimits, acc_speedup_absolute_max_),
  PROTOBUF_FIELD_OFFSET(::RobotLimits, acc_speedup_angular_max_),
  PROTOBUF_FIELD_OFFSET(::RobotLimits, acc_brake_absolute_max_),
  PROTOBUF_FIELD_OFFSET(::RobotLimits, acc_brake_angular_max_),
  PROTOBUF_FIELD_OFFSET(::RobotLimits, vel_absolute_max_),
  PROTOBUF_FIELD_OFFSET(::RobotLimits, vel_angular_max_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::RobotWheelAngles, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::RobotWheelAngles, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::RobotWheelAngles, front_right_),
  PROTOBUF_FIELD_OFFSET(::RobotWheelAngles, back_right_),
  PROTOBUF_FIELD_OFFSET(::RobotWheelAngles, back_left_),
  PROTOBUF_FIELD_OFFSET(::RobotWheelAngles, front_left_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, id_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, radius_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, height_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, mass_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, max_linear_kick_speed_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, max_chip_kick_speed_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, center_to_dribbler_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, limits_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, wheel_angles_),
  PROTOBUF_FIELD_OFFSET(::RobotSpecs, custom_),
  0,
  7,
  8,
  3,
  4,
  5,
  6,
  1,
  2,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::RealismConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::RealismConfig, custom_),
  PROTOBUF_FIELD_OFFSET(::SimulatorConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SimulatorConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SimulatorConfig, geometry_),
  PROTOBUF_FIELD_OFFSET(::SimulatorConfig, robot_specs_),
  PROTOBUF_FIELD_OFFSET(::SimulatorConfig, realism_config_),
  PROTOBUF_FIELD_OFFSET(::SimulatorConfig, vision_port_),
  0,
  ~0u,
  1,
  2,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, sizeof(::RobotLimits)},
  { 17, 26, sizeof(::RobotWheelAngles)},
  { 30, 45, sizeof(::RobotSpecs)},
  { 55, -1, sizeof(::RealismConfig)},
  { 61, 70, sizeof(::SimulatorConfig)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_RobotLimits_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_RobotWheelAngles_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_RobotSpecs_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_RealismConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SimulatorConfig_default_instance_),
};

const char descriptor_table_protodef_ssl_5fsimulation_5fconfig_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\033ssl_simulation_config.proto\032,messages_"
  "robocup_ssl_detection_tracked.proto\032#mes"
  "sages_robocup_ssl_geometry.proto\032\031google"
  "/protobuf/any.proto\"\302\001\n\013RobotLimits\022 \n\030a"
  "cc_speedup_absolute_max\030\001 \001(\002\022\037\n\027acc_spe"
  "edup_angular_max\030\002 \001(\002\022\036\n\026acc_brake_abso"
  "lute_max\030\003 \001(\002\022\035\n\025acc_brake_angular_max\030"
  "\004 \001(\002\022\030\n\020vel_absolute_max\030\005 \001(\002\022\027\n\017vel_a"
  "ngular_max\030\006 \001(\002\"b\n\020RobotWheelAngles\022\023\n\013"
  "front_right\030\001 \002(\002\022\022\n\nback_right\030\002 \002(\002\022\021\n"
  "\tback_left\030\003 \002(\002\022\022\n\nfront_left\030\004 \002(\002\"\241\002\n"
  "\nRobotSpecs\022\024\n\002id\030\001 \002(\0132\010.RobotId\022\024\n\006rad"
  "ius\030\002 \001(\002:\0040.09\022\024\n\006height\030\003 \001(\002:\0040.15\022\014\n"
  "\004mass\030\004 \001(\002\022\035\n\025max_linear_kick_speed\030\007 \001"
  "(\002\022\033\n\023max_chip_kick_speed\030\010 \001(\002\022\032\n\022cente"
  "r_to_dribbler\030\t \001(\002\022\034\n\006limits\030\n \001(\0132\014.Ro"
  "botLimits\022\'\n\014wheel_angles\030\r \001(\0132\021.RobotW"
  "heelAngles\022$\n\006custom\030\016 \003(\0132\024.google.prot"
  "obuf.Any\"5\n\rRealismConfig\022$\n\006custom\030\001 \003("
  "\0132\024.google.protobuf.Any\"\225\001\n\017SimulatorCon"
  "fig\022#\n\010geometry\030\001 \001(\0132\021.SSL_GeometryData"
  "\022 \n\013robot_specs\030\002 \003(\0132\013.RobotSpecs\022&\n\016re"
  "alism_config\030\003 \001(\0132\016.RealismConfig\022\023\n\013vi"
  "sion_port\030\004 \001(\rB8Z6github.com/RoboCup-SS"
  "L/ssl-simulation-protocol/pkg/sim"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_ssl_5fsimulation_5fconfig_2eproto_deps[3] = {
  &::descriptor_table_google_2fprotobuf_2fany_2eproto,
  &::descriptor_table_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto,
  &::descriptor_table_messages_5frobocup_5fssl_5fgeometry_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_ssl_5fsimulation_5fconfig_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ssl_5fsimulation_5fconfig_2eproto = {
  false, false, 993, descriptor_table_protodef_ssl_5fsimulation_5fconfig_2eproto, "ssl_simulation_config.proto", 
  &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_once, descriptor_table_ssl_5fsimulation_5fconfig_2eproto_deps, 3, 5,
  schemas, file_default_instances, TableStruct_ssl_5fsimulation_5fconfig_2eproto::offsets,
  file_level_metadata_ssl_5fsimulation_5fconfig_2eproto, file_level_enum_descriptors_ssl_5fsimulation_5fconfig_2eproto, file_level_service_descriptors_ssl_5fsimulation_5fconfig_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_ssl_5fsimulation_5fconfig_2eproto_getter() {
  return &descriptor_table_ssl_5fsimulation_5fconfig_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_ssl_5fsimulation_5fconfig_2eproto(&descriptor_table_ssl_5fsimulation_5fconfig_2eproto);

// ===================================================================

class RobotLimits::_Internal {
 public:
  using HasBits = decltype(std::declval<RobotLimits>()._has_bits_);
  static void set_has_acc_speedup_absolute_max(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_acc_speedup_angular_max(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_acc_brake_absolute_max(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_acc_brake_angular_max(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_vel_absolute_max(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_vel_angular_max(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

RobotLimits::RobotLimits(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RobotLimits)
}
RobotLimits::RobotLimits(const RobotLimits& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&acc_speedup_absolute_max_, &from.acc_speedup_absolute_max_,
    static_cast<size_t>(reinterpret_cast<char*>(&vel_angular_max_) -
    reinterpret_cast<char*>(&acc_speedup_absolute_max_)) + sizeof(vel_angular_max_));
  // @@protoc_insertion_point(copy_constructor:RobotLimits)
}

inline void RobotLimits::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&acc_speedup_absolute_max_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&vel_angular_max_) -
    reinterpret_cast<char*>(&acc_speedup_absolute_max_)) + sizeof(vel_angular_max_));
}

RobotLimits::~RobotLimits() {
  // @@protoc_insertion_point(destructor:RobotLimits)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RobotLimits::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RobotLimits::ArenaDtor(void* object) {
  RobotLimits* _this = reinterpret_cast< RobotLimits* >(object);
  (void)_this;
}
void RobotLimits::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RobotLimits::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RobotLimits::Clear() {
// @@protoc_insertion_point(message_clear_start:RobotLimits)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&acc_speedup_absolute_max_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&vel_angular_max_) -
        reinterpret_cast<char*>(&acc_speedup_absolute_max_)) + sizeof(vel_angular_max_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RobotLimits::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float acc_speedup_absolute_max = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_acc_speedup_absolute_max(&has_bits);
          acc_speedup_absolute_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float acc_speedup_angular_max = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_acc_speedup_angular_max(&has_bits);
          acc_speedup_angular_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float acc_brake_absolute_max = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_acc_brake_absolute_max(&has_bits);
          acc_brake_absolute_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float acc_brake_angular_max = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_acc_brake_angular_max(&has_bits);
          acc_brake_angular_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float vel_absolute_max = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_vel_absolute_max(&has_bits);
          vel_absolute_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float vel_angular_max = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_vel_angular_max(&has_bits);
          vel_angular_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RobotLimits::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RobotLimits)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float acc_speedup_absolute_max = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_acc_speedup_absolute_max(), target);
  }

  // optional float acc_speedup_angular_max = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_acc_speedup_angular_max(), target);
  }

  // optional float acc_brake_absolute_max = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_acc_brake_absolute_max(), target);
  }

  // optional float acc_brake_angular_max = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_acc_brake_angular_max(), target);
  }

  // optional float vel_absolute_max = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_vel_absolute_max(), target);
  }

  // optional float vel_angular_max = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_vel_angular_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RobotLimits)
  return target;
}

size_t RobotLimits::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RobotLimits)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional float acc_speedup_absolute_max = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float acc_speedup_angular_max = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float acc_brake_absolute_max = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float acc_brake_angular_max = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float vel_absolute_max = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float vel_angular_max = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RobotLimits::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RobotLimits::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RobotLimits::GetClassData() const { return &_class_data_; }

void RobotLimits::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<RobotLimits *>(to)->MergeFrom(
      static_cast<const RobotLimits &>(from));
}


void RobotLimits::MergeFrom(const RobotLimits& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RobotLimits)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      acc_speedup_absolute_max_ = from.acc_speedup_absolute_max_;
    }
    if (cached_has_bits & 0x00000002u) {
      acc_speedup_angular_max_ = from.acc_speedup_angular_max_;
    }
    if (cached_has_bits & 0x00000004u) {
      acc_brake_absolute_max_ = from.acc_brake_absolute_max_;
    }
    if (cached_has_bits & 0x00000008u) {
      acc_brake_angular_max_ = from.acc_brake_angular_max_;
    }
    if (cached_has_bits & 0x00000010u) {
      vel_absolute_max_ = from.vel_absolute_max_;
    }
    if (cached_has_bits & 0x00000020u) {
      vel_angular_max_ = from.vel_angular_max_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RobotLimits::CopyFrom(const RobotLimits& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RobotLimits)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotLimits::IsInitialized() const {
  return true;
}

void RobotLimits::InternalSwap(RobotLimits* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RobotLimits, vel_angular_max_)
      + sizeof(RobotLimits::vel_angular_max_)
      - PROTOBUF_FIELD_OFFSET(RobotLimits, acc_speedup_absolute_max_)>(
          reinterpret_cast<char*>(&acc_speedup_absolute_max_),
          reinterpret_cast<char*>(&other->acc_speedup_absolute_max_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RobotLimits::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_getter, &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_once,
      file_level_metadata_ssl_5fsimulation_5fconfig_2eproto[0]);
}

// ===================================================================

class RobotWheelAngles::_Internal {
 public:
  using HasBits = decltype(std::declval<RobotWheelAngles>()._has_bits_);
  static void set_has_front_right(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_back_right(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_back_left(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_front_left(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

RobotWheelAngles::RobotWheelAngles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RobotWheelAngles)
}
RobotWheelAngles::RobotWheelAngles(const RobotWheelAngles& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&front_right_, &from.front_right_,
    static_cast<size_t>(reinterpret_cast<char*>(&front_left_) -
    reinterpret_cast<char*>(&front_right_)) + sizeof(front_left_));
  // @@protoc_insertion_point(copy_constructor:RobotWheelAngles)
}

inline void RobotWheelAngles::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&front_right_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&front_left_) -
    reinterpret_cast<char*>(&front_right_)) + sizeof(front_left_));
}

RobotWheelAngles::~RobotWheelAngles() {
  // @@protoc_insertion_point(destructor:RobotWheelAngles)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RobotWheelAngles::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RobotWheelAngles::ArenaDtor(void* object) {
  RobotWheelAngles* _this = reinterpret_cast< RobotWheelAngles* >(object);
  (void)_this;
}
void RobotWheelAngles::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RobotWheelAngles::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RobotWheelAngles::Clear() {
// @@protoc_insertion_point(message_clear_start:RobotWheelAngles)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&front_right_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&front_left_) -
        reinterpret_cast<char*>(&front_right_)) + sizeof(front_left_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RobotWheelAngles::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required float front_right = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_front_right(&has_bits);
          front_right_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float back_right = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_back_right(&has_bits);
          back_right_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float back_left = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_back_left(&has_bits);
          back_left_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float front_left = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_front_left(&has_bits);
          front_left_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RobotWheelAngles::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RobotWheelAngles)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required float front_right = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_front_right(), target);
  }

  // required float back_right = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_back_right(), target);
  }

  // required float back_left = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_back_left(), target);
  }

  // required float front_left = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_front_left(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RobotWheelAngles)
  return target;
}

size_t RobotWheelAngles::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:RobotWheelAngles)
  size_t total_size = 0;

  if (_internal_has_front_right()) {
    // required float front_right = 1;
    total_size += 1 + 4;
  }

  if (_internal_has_back_right()) {
    // required float back_right = 2;
    total_size += 1 + 4;
  }

  if (_internal_has_back_left()) {
    // required float back_left = 3;
    total_size += 1 + 4;
  }

  if (_internal_has_front_left()) {
    // required float front_left = 4;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t RobotWheelAngles::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RobotWheelAngles)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required float front_right = 1;
    total_size += 1 + 4;

    // required float back_right = 2;
    total_size += 1 + 4;

    // required float back_left = 3;
    total_size += 1 + 4;

    // required float front_left = 4;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RobotWheelAngles::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RobotWheelAngles::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RobotWheelAngles::GetClassData() const { return &_class_data_; }

void RobotWheelAngles::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<RobotWheelAngles *>(to)->MergeFrom(
      static_cast<const RobotWheelAngles &>(from));
}


void RobotWheelAngles::MergeFrom(const RobotWheelAngles& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RobotWheelAngles)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      front_right_ = from.front_right_;
    }
    if (cached_has_bits & 0x00000002u) {
      back_right_ = from.back_right_;
    }
    if (cached_has_bits & 0x00000004u) {
      back_left_ = from.back_left_;
    }
    if (cached_has_bits & 0x00000008u) {
      front_left_ = from.front_left_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RobotWheelAngles::CopyFrom(const RobotWheelAngles& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RobotWheelAngles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotWheelAngles::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RobotWheelAngles::InternalSwap(RobotWheelAngles* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RobotWheelAngles, front_left_)
      + sizeof(RobotWheelAngles::front_left_)
      - PROTOBUF_FIELD_OFFSET(RobotWheelAngles, front_right_)>(
          reinterpret_cast<char*>(&front_right_),
          reinterpret_cast<char*>(&other->front_right_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RobotWheelAngles::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_getter, &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_once,
      file_level_metadata_ssl_5fsimulation_5fconfig_2eproto[1]);
}

// ===================================================================

class RobotSpecs::_Internal {
 public:
  using HasBits = decltype(std::declval<RobotSpecs>()._has_bits_);
  static const ::RobotId& id(const RobotSpecs* msg);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_mass(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_max_linear_kick_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_max_chip_kick_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_center_to_dribbler(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::RobotLimits& limits(const RobotSpecs* msg);
  static void set_has_limits(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::RobotWheelAngles& wheel_angles(const RobotSpecs* msg);
  static void set_has_wheel_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::RobotId&
RobotSpecs::_Internal::id(const RobotSpecs* msg) {
  return *msg->id_;
}
const ::RobotLimits&
RobotSpecs::_Internal::limits(const RobotSpecs* msg) {
  return *msg->limits_;
}
const ::RobotWheelAngles&
RobotSpecs::_Internal::wheel_angles(const RobotSpecs* msg) {
  return *msg->wheel_angles_;
}
void RobotSpecs::clear_id() {
  if (id_ != nullptr) id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void RobotSpecs::clear_custom() {
  custom_.Clear();
}
RobotSpecs::RobotSpecs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  custom_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RobotSpecs)
}
RobotSpecs::RobotSpecs(const RobotSpecs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      custom_(from.custom_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_id()) {
    id_ = new ::RobotId(*from.id_);
  } else {
    id_ = nullptr;
  }
  if (from._internal_has_limits()) {
    limits_ = new ::RobotLimits(*from.limits_);
  } else {
    limits_ = nullptr;
  }
  if (from._internal_has_wheel_angles()) {
    wheel_angles_ = new ::RobotWheelAngles(*from.wheel_angles_);
  } else {
    wheel_angles_ = nullptr;
  }
  ::memcpy(&mass_, &from.mass_,
    static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&mass_)) + sizeof(height_));
  // @@protoc_insertion_point(copy_constructor:RobotSpecs)
}

inline void RobotSpecs::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&center_to_dribbler_) -
    reinterpret_cast<char*>(&id_)) + sizeof(center_to_dribbler_));
radius_ = 0.09f;
height_ = 0.15f;
}

RobotSpecs::~RobotSpecs() {
  // @@protoc_insertion_point(destructor:RobotSpecs)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RobotSpecs::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete id_;
  if (this != internal_default_instance()) delete limits_;
  if (this != internal_default_instance()) delete wheel_angles_;
}

void RobotSpecs::ArenaDtor(void* object) {
  RobotSpecs* _this = reinterpret_cast< RobotSpecs* >(object);
  (void)_this;
}
void RobotSpecs::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RobotSpecs::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RobotSpecs::Clear() {
// @@protoc_insertion_point(message_clear_start:RobotSpecs)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  custom_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(id_ != nullptr);
      id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(limits_ != nullptr);
      limits_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(wheel_angles_ != nullptr);
      wheel_angles_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&mass_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&center_to_dribbler_) -
        reinterpret_cast<char*>(&mass_)) + sizeof(center_to_dribbler_));
    radius_ = 0.09f;
  }
  height_ = 0.15f;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RobotSpecs::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .RobotId id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float radius = 2 [default = 0.09];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_radius(&has_bits);
          radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float height = 3 [default = 0.15];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float mass = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_mass(&has_bits);
          mass_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float max_linear_kick_speed = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_max_linear_kick_speed(&has_bits);
          max_linear_kick_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float max_chip_kick_speed = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_max_chip_kick_speed(&has_bits);
          max_chip_kick_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float center_to_dribbler = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          _Internal::set_has_center_to_dribbler(&has_bits);
          center_to_dribbler_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .RobotLimits limits = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_limits(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .RobotWheelAngles wheel_angles = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_wheel_angles(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .google.protobuf.Any custom = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_custom(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RobotSpecs::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RobotSpecs)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .RobotId id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // optional float radius = 2 [default = 0.09];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_radius(), target);
  }

  // optional float height = 3 [default = 0.15];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_height(), target);
  }

  // optional float mass = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_mass(), target);
  }

  // optional float max_linear_kick_speed = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_max_linear_kick_speed(), target);
  }

  // optional float max_chip_kick_speed = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_max_chip_kick_speed(), target);
  }

  // optional float center_to_dribbler = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_center_to_dribbler(), target);
  }

  // optional .RobotLimits limits = 10;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::limits(this), target, stream);
  }

  // optional .RobotWheelAngles wheel_angles = 13;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        13, _Internal::wheel_angles(this), target, stream);
  }

  // repeated .google.protobuf.Any custom = 14;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_custom_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, this->_internal_custom(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RobotSpecs)
  return target;
}

size_t RobotSpecs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RobotSpecs)
  size_t total_size = 0;

  // required .RobotId id = 1;
  if (_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *id_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Any custom = 14;
  total_size += 1UL * this->_internal_custom_size();
  for (const auto& msg : this->custom_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional .RobotLimits limits = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *limits_);
    }

    // optional .RobotWheelAngles wheel_angles = 13;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wheel_angles_);
    }

    // optional float mass = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float max_linear_kick_speed = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float max_chip_kick_speed = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float center_to_dribbler = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float radius = 2 [default = 0.09];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  // optional float height = 3 [default = 0.15];
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RobotSpecs::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RobotSpecs::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RobotSpecs::GetClassData() const { return &_class_data_; }

void RobotSpecs::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<RobotSpecs *>(to)->MergeFrom(
      static_cast<const RobotSpecs &>(from));
}


void RobotSpecs::MergeFrom(const RobotSpecs& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RobotSpecs)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  custom_.MergeFrom(from.custom_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_id()->::RobotId::MergeFrom(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_limits()->::RobotLimits::MergeFrom(from._internal_limits());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_wheel_angles()->::RobotWheelAngles::MergeFrom(from._internal_wheel_angles());
    }
    if (cached_has_bits & 0x00000008u) {
      mass_ = from.mass_;
    }
    if (cached_has_bits & 0x00000010u) {
      max_linear_kick_speed_ = from.max_linear_kick_speed_;
    }
    if (cached_has_bits & 0x00000020u) {
      max_chip_kick_speed_ = from.max_chip_kick_speed_;
    }
    if (cached_has_bits & 0x00000040u) {
      center_to_dribbler_ = from.center_to_dribbler_;
    }
    if (cached_has_bits & 0x00000080u) {
      radius_ = from.radius_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_height(from._internal_height());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RobotSpecs::CopyFrom(const RobotSpecs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RobotSpecs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotSpecs::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_id()) {
    if (!id_->IsInitialized()) return false;
  }
  if (_internal_has_wheel_angles()) {
    if (!wheel_angles_->IsInitialized()) return false;
  }
  return true;
}

void RobotSpecs::InternalSwap(RobotSpecs* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  custom_.InternalSwap(&other->custom_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RobotSpecs, center_to_dribbler_)
      + sizeof(RobotSpecs::center_to_dribbler_)
      - PROTOBUF_FIELD_OFFSET(RobotSpecs, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
  swap(radius_, other->radius_);
  swap(height_, other->height_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RobotSpecs::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_getter, &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_once,
      file_level_metadata_ssl_5fsimulation_5fconfig_2eproto[2]);
}

// ===================================================================

class RealismConfig::_Internal {
 public:
};

void RealismConfig::clear_custom() {
  custom_.Clear();
}
RealismConfig::RealismConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  custom_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RealismConfig)
}
RealismConfig::RealismConfig(const RealismConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      custom_(from.custom_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:RealismConfig)
}

inline void RealismConfig::SharedCtor() {
}

RealismConfig::~RealismConfig() {
  // @@protoc_insertion_point(destructor:RealismConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RealismConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RealismConfig::ArenaDtor(void* object) {
  RealismConfig* _this = reinterpret_cast< RealismConfig* >(object);
  (void)_this;
}
void RealismConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RealismConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RealismConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:RealismConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  custom_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RealismConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .google.protobuf.Any custom = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_custom(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RealismConfig::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RealismConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .google.protobuf.Any custom = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_custom_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_custom(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RealismConfig)
  return target;
}

size_t RealismConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RealismConfig)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Any custom = 1;
  total_size += 1UL * this->_internal_custom_size();
  for (const auto& msg : this->custom_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RealismConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RealismConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RealismConfig::GetClassData() const { return &_class_data_; }

void RealismConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<RealismConfig *>(to)->MergeFrom(
      static_cast<const RealismConfig &>(from));
}


void RealismConfig::MergeFrom(const RealismConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RealismConfig)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  custom_.MergeFrom(from.custom_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RealismConfig::CopyFrom(const RealismConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RealismConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RealismConfig::IsInitialized() const {
  return true;
}

void RealismConfig::InternalSwap(RealismConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  custom_.InternalSwap(&other->custom_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RealismConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_getter, &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_once,
      file_level_metadata_ssl_5fsimulation_5fconfig_2eproto[3]);
}

// ===================================================================

class SimulatorConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<SimulatorConfig>()._has_bits_);
  static const ::SSL_GeometryData& geometry(const SimulatorConfig* msg);
  static void set_has_geometry(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::RealismConfig& realism_config(const SimulatorConfig* msg);
  static void set_has_realism_config(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vision_port(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::SSL_GeometryData&
SimulatorConfig::_Internal::geometry(const SimulatorConfig* msg) {
  return *msg->geometry_;
}
const ::RealismConfig&
SimulatorConfig::_Internal::realism_config(const SimulatorConfig* msg) {
  return *msg->realism_config_;
}
void SimulatorConfig::clear_geometry() {
  if (geometry_ != nullptr) geometry_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
SimulatorConfig::SimulatorConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  robot_specs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SimulatorConfig)
}
SimulatorConfig::SimulatorConfig(const SimulatorConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      robot_specs_(from.robot_specs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_geometry()) {
    geometry_ = new ::SSL_GeometryData(*from.geometry_);
  } else {
    geometry_ = nullptr;
  }
  if (from._internal_has_realism_config()) {
    realism_config_ = new ::RealismConfig(*from.realism_config_);
  } else {
    realism_config_ = nullptr;
  }
  vision_port_ = from.vision_port_;
  // @@protoc_insertion_point(copy_constructor:SimulatorConfig)
}

inline void SimulatorConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&geometry_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&vision_port_) -
    reinterpret_cast<char*>(&geometry_)) + sizeof(vision_port_));
}

SimulatorConfig::~SimulatorConfig() {
  // @@protoc_insertion_point(destructor:SimulatorConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SimulatorConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete geometry_;
  if (this != internal_default_instance()) delete realism_config_;
}

void SimulatorConfig::ArenaDtor(void* object) {
  SimulatorConfig* _this = reinterpret_cast< SimulatorConfig* >(object);
  (void)_this;
}
void SimulatorConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SimulatorConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SimulatorConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:SimulatorConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  robot_specs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(geometry_ != nullptr);
      geometry_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(realism_config_ != nullptr);
      realism_config_->Clear();
    }
  }
  vision_port_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SimulatorConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .SSL_GeometryData geometry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_geometry(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .RobotSpecs robot_specs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_robot_specs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .RealismConfig realism_config = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_realism_config(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 vision_port = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_vision_port(&has_bits);
          vision_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SimulatorConfig::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SimulatorConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .SSL_GeometryData geometry = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::geometry(this), target, stream);
  }

  // repeated .RobotSpecs robot_specs = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_robot_specs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_robot_specs(i), target, stream);
  }

  // optional .RealismConfig realism_config = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::realism_config(this), target, stream);
  }

  // optional uint32 vision_port = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_vision_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SimulatorConfig)
  return target;
}

size_t SimulatorConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SimulatorConfig)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .RobotSpecs robot_specs = 2;
  total_size += 1UL * this->_internal_robot_specs_size();
  for (const auto& msg : this->robot_specs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .SSL_GeometryData geometry = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *geometry_);
    }

    // optional .RealismConfig realism_config = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *realism_config_);
    }

    // optional uint32 vision_port = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_vision_port());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SimulatorConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SimulatorConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SimulatorConfig::GetClassData() const { return &_class_data_; }

void SimulatorConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<SimulatorConfig *>(to)->MergeFrom(
      static_cast<const SimulatorConfig &>(from));
}


void SimulatorConfig::MergeFrom(const SimulatorConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SimulatorConfig)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  robot_specs_.MergeFrom(from.robot_specs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_geometry()->::SSL_GeometryData::MergeFrom(from._internal_geometry());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_realism_config()->::RealismConfig::MergeFrom(from._internal_realism_config());
    }
    if (cached_has_bits & 0x00000004u) {
      vision_port_ = from.vision_port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SimulatorConfig::CopyFrom(const SimulatorConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SimulatorConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimulatorConfig::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(robot_specs_)) return false;
  if (_internal_has_geometry()) {
    if (!geometry_->IsInitialized()) return false;
  }
  return true;
}

void SimulatorConfig::InternalSwap(SimulatorConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  robot_specs_.InternalSwap(&other->robot_specs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SimulatorConfig, vision_port_)
      + sizeof(SimulatorConfig::vision_port_)
      - PROTOBUF_FIELD_OFFSET(SimulatorConfig, geometry_)>(
          reinterpret_cast<char*>(&geometry_),
          reinterpret_cast<char*>(&other->geometry_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SimulatorConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_getter, &descriptor_table_ssl_5fsimulation_5fconfig_2eproto_once,
      file_level_metadata_ssl_5fsimulation_5fconfig_2eproto[4]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::RobotLimits* Arena::CreateMaybeMessage< ::RobotLimits >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RobotLimits >(arena);
}
template<> PROTOBUF_NOINLINE ::RobotWheelAngles* Arena::CreateMaybeMessage< ::RobotWheelAngles >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RobotWheelAngles >(arena);
}
template<> PROTOBUF_NOINLINE ::RobotSpecs* Arena::CreateMaybeMessage< ::RobotSpecs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RobotSpecs >(arena);
}
template<> PROTOBUF_NOINLINE ::RealismConfig* Arena::CreateMaybeMessage< ::RealismConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RealismConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::SimulatorConfig* Arena::CreateMaybeMessage< ::SimulatorConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SimulatorConfig >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
